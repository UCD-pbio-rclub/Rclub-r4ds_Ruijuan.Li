---
title: "R_club"
author: "Ruijuan Li"
date: "4/12/2017"
output: html_document
---

# 04-12-2017 
```{r}
# expand.grid(1:3, letters) 
```

# 04-26-2017 
```{r include=FALSE}
colorFunc <- "heat.colors"
colorFunc <- "terrain.colors"

```

## `r colorFunc`
```{r fig.cap="The Mounga Whau volcano.", echo=FALSE}
image(volcano, col = get(colorFunc)(200))
```

# book reading & practice 
```{r}
# install.packages("tidyverse")
library(tidyverse)
ggplot2::ggplot()

# data.frame VS matrix VS data.matrix VS as.data.frame 

mpg
class(mpg)
```

```{r}
# plot 
ggplot(data = mpg) + geom_point(mapping = aes(x=displ, y= hwy))
# mapping? 

# Each geom function in ggplot2 takes a mapping argument. This defines how variables in your dataset are mapped to visual properties.The mapping argument is always paired with aes(), and the x and y arguments of aes() specify which variables to map to the x and y axes.  
```

```{r}
# template 
# ggplot(data = <DATA>) + 
#   <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))  
```

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class)) 

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))

# mapping an unordered variable (class) to an ordered aesthetic (size) is not a good idea. 

# Left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))

# Right
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))

# ggplot2 will only use six shapes at a time. By default, additional groups will go unplotted when you use the shape aesthetic. 

# set the aesthetic properties of your geom manually. For example, we can make all of the points in our plot blue

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "red", size = 3, shape = 0, fill="red")
# To set an aesthetic manually, set the aesthetic by name as an argument of your geom function; i.e. it goes outside of aes(). 

# how to fill? 

# To facet your plot by a single variable, use facet_wrap(); The variable that you pass to facet_wrap() should be discrete. 

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)

# To facet your plot on the combination of two variables, add facet_grid() to your plot call. 

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid( ~ cyl)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ .)

```

# 05-02-2017
```{r}
library(ggplot2)
# left
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))

# right
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))

ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))

mpg$drv

# compared to linetype, better to use group because it doens't add extra legend 
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
              
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
    
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, group = drv)
  )

# multiple geom 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))

# global mapping 
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

# overlay with color 
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()

# the use of filter 
library(dplyr)
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) +  
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)

# statistical transformation
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))

# stat_count & geom_bar are the same thing 
ggplot(data = diamonds) + 
  stat_count(mapping = aes(x = cut))

# use identity as stats 
library(tibble)
demo <- tribble(
  ~a,      ~b,
  "bar_1", 20,
  "bar_2", 30,
  "bar_3", 40
)
ggplot(data = demo) +
  geom_bar(mapping = aes(x = a, y = b), stat = "identity")

# use proportion as stats
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1)) 

# stat_summary 
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  )

# color vs fill 
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))

# Each colored rectangle represents a combination of cut and clarity
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))

# position: identity OR dodge OR fill OR jitter OR stack 
# position = "identity" will place each object exactly where it falls in the context of the graph. This is not very useful for bars, because it overlaps them.

ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")

# position = "fill" works like stacking, but makes each set of stacked bars the same height. This makes it easier to compare proportions across groups.

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")

# position = "dodge" places overlapping objects directly beside one another. This makes it easier to compare individual values 
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")

# overplotting problem for scatterplot 
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")

#### coordinate system 
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot()
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot() +
  coord_flip()

# install.packages("maps")
library("maps")
nz <- map_data("nz")

ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black")

ggplot(nz, aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  coord_quickmap()

bar <- ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, fill = cut), 
    show.legend = FALSE,
    width = 1
  ) + 
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL)

bar
bar + coord_flip()
bar + coord_polar() 

# calculate proportion within each group 
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity, y = ..prop..)) 

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")

p <- ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop.., fill = color))  

grid_arrange
install.packages("gridExtra")
library("gridExtra")   
```

# 05-09-2017 
```{r}
# install.packages("nycflights13")
library(nycflights13)
library(tidyverse)

flights # Tibbles are data frames, but slightly tweaked to work better in the tidyverse.  

# Filter rows with filter() 
filter(flights, month == 1, day == 1)
jan1 <- filter(flights, month == 1, day == 1)
(dec25 <- filter(flights, month == 12, day == 25))

sqrt(2) ^ 2 == 2
1/49 * 49 == 1

near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)

tmp <- filter(flights, month == 11 | month == 12)
nov_dec <- filter(flights, month %in% c(11, 12))
identical(tmp, nov_dec)

filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)

# As well as & and |, R also has && and ||. Don’t use them here!  
df <- tibble(x = c(1, NA, 3))
df
filter(df, x > 1)
filter(df, is.na(x) | x > 1)

# Arrange rows with arrange()
arrange(flights, year, month, day)
arrange(flights, desc(arr_delay))

### Select columns with select()
select(flights, year, month, day)
select(flights, year:day)
select(flights, -(year:day)) # deselect certain colnames 
colnames(select(flights, matches("(.)\\1")))  ### repeated character... 
?select
rename(flights, tail_num = tailnum)$tail_num # rename certain colnames 
dim(select(flights, time_hour, air_time, everything())) # move time_hour & air_time to the beginning of the df
dim(flights)

# 5.5 Add new variables with mutate() # add new columns which are functions of the existing columns 
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)

dim(flights_sml)

tmp <- mutate(flights_sml,
  gain = arr_delay - dep_delay,
  speed = distance / air_time * 60
)

dim(tmp)

tmp2 <- mutate(flights_sml,
  gain = arr_delay - dep_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)

dim(tmp2)

transmute(flights,
  gain = arr_delay - dep_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
) # only keep the new variables 

colnames(flights)

transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
flights$dep_time

?lead
lead(1:10, 1)
lead(1:10, 2)
lag(1:10, 1)

x <- runif(5)
x
cbind(ahead = lead(x), x, behind = lag(x))

df <- data.frame(year = 2000:2005, value = (0:5) ^ 2)
df
scrambled <- df[sample(nrow(df)), ]
scrambled
wrong <- mutate(scrambled, prev = lag(value))
arrange(wrong, year)

right <- mutate(scrambled, prev = lag(value, order_by = year))
arrange(right, year)

x <- c(1:10)
x
cumsum(x)
cummean(x)

y <- c(1, 2, 2, NA, 3, 4)
min_rank(y) 
min_rank(desc(y))
row_number(y)
dense_rank(y)
percent_rank(y)
cume_dist(y)

```

# 05-16-2017 
```{r}
library(nycflights13)
library(tidyverse)

# introduce group_by & summarise 
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
dim(flights) # 336776     19
by_day <- group_by(flights, year, month, day)
dim(by_day) # 336776     19 
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))

# pipe 
# Combining multiple operations with the pipe 
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
  count = n(), # what is this??? 
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
delay <- filter(delay, count > 20, dest != "HNL")

ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
  geom_point(aes(size = count), alpha = 1/3) +
  geom_smooth(se = FALSE)

ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
  geom_point(aes(size = count), alpha = 1/3) +
  geom_smooth(se = T)

# se specify whether plot confidence interval 
delays <- flights %>% 
  group_by(dest) %>% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>% 
  filter(count > 20, dest != "HNL")

# missing values 
flights %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay))

tmp1 <- flights %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay, na.rm = TRUE))

not_cancelled <- flights %>% 
  filter(!is.na(dep_delay), !is.na(arr_delay))

tmp2 <- not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay))

dim(tmp1)
dim(tmp2)
head(tmp1)
head(tmp2)
identical(tmp1, tmp2)

### rm.na still keep the data as one data? 
### so tmp1 & tmp2 are different... 

# Counts 
delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay)
  )

ggplot(data = delays, mapping = aes(x = delay)) + 
  geom_freqpoly(binwidth = 10)

ggplot(data = delays, mapping = aes(x = delay)) + 
  geom_freqpoly(binwidth = 100)

ggplot(data = delays, mapping = aes(x = delay)) + 
  geom_freqpoly(binwidth = 1)

?geom_freqpoly
 # Visualise the distribution of a single continuous variable by dividing the x axis into bins and counting the number of observations in each bin. Histograms (geom_histogram) display the count with bars; frequency polygons (geom_freqpoly), display the counts with lines. Frequency polygons are more suitable when you want to compare the distribution across a the levels of a categorical variable. 

delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE), # na.rm TRUE or FALSE has no effect here 
    n = n() # don't know this... 
  )

ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)

delays %>% 
  filter(n > 25) %>% 
  ggplot(mapping = aes(x = n, y = delay)) + 
    geom_point(alpha = 1/10)

# RStudio tip: a useful keyboard shortcut is Cmd/Ctrl + Shift + P. This resends the previously sent chunk from the editor to the console. This is very convenient when you’re (e.g.) exploring the value of n in the example above. You send the whole block once with Cmd/Ctrl + Enter, then you modify the value of n and press Cmd/Ctrl + Shift + P to resend the complete block. ######### what??? don't understand !!!!!!!!!

# install.packages("Lahman")
library("Lahman")

batting <- as_tibble(Lahman::Batting)

batters <- batting %>% 
  group_by(playerID) %>% 
  summarise(
    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    ab = sum(AB, na.rm = TRUE)
  )

batters %>% 
  filter(ab > 100) %>% 
  ggplot(mapping = aes(x = ab, y = ba)) +
    geom_point() + 
    geom_smooth(se = FALSE)

batters %>% 
  arrange(desc(ba))

#### Useful summary functions
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    avg_delay1 = mean(arr_delay),
    avg_delay2 = mean(arr_delay[arr_delay > 0]) # the average positive delay
  )

not_cancelled %>% 
  group_by(dest) %>% 
  summarise(distance_sd = sd(distance)) %>% 
  arrange(desc(distance_sd))

not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first = min(dep_time),
    last = max(dep_time)
  )

not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first_dep = first(dep_time), 
    last_dep = last(dep_time)
  )

tmp <- 
not_cancelled %>% 
  group_by(year, month, day) %>% 
  mutate(r = min_rank(desc(dep_time))) %>% 
  filter(r %in% range(r)) # don't understand the last line of code... 

tmp2 <- 
not_cancelled %>% 
  group_by(year, month, day) %>% 
  mutate(r = min_rank(desc(dep_time))) 

?range  
identical(tmp, tmp2)

not_cancelled %>% 
  group_by(dest) %>% 
  summarise(carriers = n_distinct(carrier)) %>% 
  arrange(desc(carriers))

not_cancelled %>% 
  count(dest)

# n() takes no arguments, and returns the size of the current group.

not_cancelled %>% 
  count(tailnum, wt = distance) # the total number of miles a plane flew 

not_cancelled %>% 
  count(tailnum)
```

# 05-23-2017 
```{r}
library(tidyverse)
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut))

diamonds %>% 
  count(cut)

ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)

diamonds %>% 
  count(cut_width(carat, 0.5)) # this is very useful, can be used in window size... 

summary(diamonds)

smaller <- diamonds %>% 
  filter(carat < 3)
  
ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.1)

ggplot(data = smaller, mapping = aes(x = carat, colour = cut)) +
  geom_freqpoly(binwidth = 0.1) # this can be useful for my data analysis 

ggplot(data = faithful, mapping = aes(x = eruptions)) + 
  geom_histogram(binwidth = 0.25)

ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)

ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50)) # zoom in to see outliners 

unusual <- diamonds %>% 
  filter(y < 3 | y > 20) %>% 
  select(price, x, y, z) %>%
  arrange(y)
unusual

summary(diamonds)
sample(1:594, 1, replace = F) # pick a question from leetcode... 
 
diamonds2 <- diamonds %>% 
  mutate(y = ifelse(y < 3 | y > 20, NA, y))

ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + 
  geom_point()

nycflights13::flights %>% 
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + sched_min / 60
  ) %>% 
  ggplot(mapping = aes(sched_dep_time)) + 
    geom_freqpoly(mapping = aes(colour = cancelled), binwidth = 1/4)

ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) + 
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500) # this can be useful for my data 

ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
  geom_boxplot() # geom box plot can be useful 

ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
  geom_boxplot()

ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) # reorder based on median value of 

ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +
  coord_flip()

diamonds %>% 
  count(color, cut)

diamonds %>% 
  count(color, cut) %>%  
  ggplot(mapping = aes(x = color, y = cut)) +
    geom_tile(mapping = aes(fill = n))

# install.packages("hexbin")
library(hexbin)
ggplot(data = smaller) +
  geom_bin2d(mapping = aes(x = carat, y = price))

ggplot(data = smaller) +
  geom_hex(mapping = aes(x = carat, y = price))

```

05-28-2017
```{r}
# 7.6 Patterns & models 
library(modelr)
library(ggplot2)
library(tidyverse)

mod <- lm(log(price) ~ log(carat), data = diamonds)
mod

diamonds2 <- diamonds %>% 
  add_residuals(mod) %>% 
  mutate(resid = exp(resid))
?add_residuals # add residuals to a data frame 
add_residuals(data = diamonds, model = mod) 
?exp # compute the exponential function 
# The residuals give us a view of the price of the diamond, once the effect of carat has been removed. 

ggplot(data = diamonds2) + 
  geom_point(mapping = aes(x = carat, y = resid))
# when carat is small, residual is high, when carat if high, residual is low. higher precision when carat is high, lower precision when carat is low, this is due to the log transformation.  

# I want to plot how the data fit the model
ggplot(data = diamonds2) + 
  geom_point(mapping = aes(x=log(carat), y=log(price), alpha=0.01)) + 
  geom_abline(intercept = mod$coefficients[[1]], slope = mod$coefficients[[2]], color="red")

ggplot(data = diamonds2) + 
  geom_boxplot(mapping = aes(x = cut, y = resid))

# 7.7 ggplot2 calls 

# 10.2 creating tibbles 
as.tibble(iris)

tibble(
  x = 1:5, 
  y = 1, 
  z = x ^ 2 + y
)

# It’s possible for a tibble to have column names that are not valid R variable names, aka non-syntactic names.  
tb <- tibble(
  `:)` = "smile", 
  ` ` = "space",
  `2000` = "number"
)

tb

# 10.3 tibbles vs. data.frame 
# printing diff 
# Tibbles have a refined print method that shows only the first 10 rows, and all the columns that fit on screen. This makes it much easier to work with large data. In addition to its name, each column reports its type, a nice feature borrowed from str(): 

tibble(
  a = lubridate::now() + runif(1e3) * 86400,
  b = lubridate::today() + runif(1e3) * 30,
  c = 1:1e3,
  d = runif(1e3),
  e = sample(letters, 1e3, replace = TRUE)
)

nycflights13::flights %>% 
  print(n = 10, width = Inf)

# subsetting 
df <- tibble(
  x = runif(5),
  y = rnorm(5)
)

df$x
df[["x"]]
df[[1]]
df[,1]
# tibble doesn't do partial matching, so that means not very useful in real world analysis 

# 10.4 interacting with older code 
```

# 06-07-2017 
```{r}
# data import 
library(tidyverse)
?read_fwf
fwf_sample <- readr_example("fwf-sample.txt")
fwf_sample
cat(read_lines(fwf_sample))
?read_log

read_csv("a,b,c
1,2,3
4,5,6")

read_csv("The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3", skip = 2) # skip might be useful in my analysis 

read_csv("The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3")

read_csv("# A comment I want to skip
  x,y,z
  1,2,3", comment = "#")

read_csv("1,2,3\n4,5,6", col_names = FALSE)

read_csv("a,b,c\n1,2,.", na = ".")

### parse vector 
# number 
parse_double("1.23")
parse_double("1,23", locale = locale(decimal_mark = ","))

parse_number("$100")
parse_number("20%")
parse_number("It cost $123.45") # these can be very useful in data parsing... 

# Used in America
parse_number("$123,456,789")
#> [1] 1.23e+08

# Used in many parts of Europe
parse_number("123.456.789", locale = locale(grouping_mark = "."))
#> [1] 1.23e+08

# Used in Switzerland
parse_number("123'456'789", locale = locale(grouping_mark = "'"))
#> [1] 1.23e+08 
# the above can be useful for collaboration... 

# string 
x1 <- "El Ni\xf1o was particularly bad this year"
x2 <- "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"

x1
#> [1] "El Ni\xf1o was particularly bad this year"
x2
#> [1] "\x82\xb1\x82\xf1\x82ɂ\xbf\x82\xcd"

parse_character(x1, locale = locale(encoding = "Latin1"))
#> [1] "El Niño was particularly bad this year"
parse_character(x2, locale = locale(encoding = "Shift-JIS"))
#> [1] "こんにちは"

# use guess_encoding 
guess_encoding(charToRaw(x1))
#> # A tibble: 2 × 2
#>     encoding confidence
#>        <chr>      <dbl>
#> 1 ISO-8859-1       0.46
#> 2 ISO-8859-9       0.23
guess_encoding(charToRaw(x2))
#> # A tibble: 1 × 2
#>   encoding confidence
#>      <chr>      <dbl>
#> 1   KOI8-R       0.42

#### Factors 
fruit <- c("apple", "banana")
parse_factor(c("apple", "banana", "bananana"), levels = fruit)

fruit <- c("apple", "banana", "bananana")
parse_factor(c("apple", "banana", "bananana"), levels = fruit)

# Dates, date-times, and times 
parse_datetime("2010-10-01T2010")
#> [1] "2010-10-01 20:10:00 UTC"
# If time is omitted, it will be set to midnight
parse_datetime("20101010")
#> [1] "2010-10-10 UTC"

library(hms)
parse_time("01:10 am")
#> 01:10:00
parse_time("20:10:01")
#> 20:10:01

parse_date("01/02/15", "%m/%d/%y")
#> [1] "2015-01-02"
parse_date("01/02/15", "%d/%m/%y")
#> [1] "2015-02-01"
parse_date("01/02/15", "%y/%m/%d")
#> [1] "2001-02-15"

# Other Types of Data
# many useful packages to extract information from different type of data 


```


